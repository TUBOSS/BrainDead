/*******************************************************************************
 * Copyright (c) 2010, Jean-David Gadina - www.xs-labs.com
 * Distributed under the Boost Software License, Version 1.0.
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 ******************************************************************************/

/* $Id$ */

/*!
 * @header      stack.c
 * @copyright   (c) 2010 - Jean-David Gadina - www.xs-labs.com
 * @abstract    Stack management
 */

#include "braindead.h"

/*!
 * @function    bd_new_stack
 * @abstract    Creates a new stack
 * @param       xalloc  The number of cells to allocate at a time
 * @result      A pointer to the stack, or NULL. You are responsible to destroy it by invoking the 'bd_delete_stack' function.
 */
bd_stack * bd_new_stack( unsigned int xalloc )
{
    bd_stack   * stack = NULL;
    bd_cell    * cells = NULL;
    unsigned int i     = 0;
    
    if( NULL == ( stack = ( bd_stack * )malloc( sizeof( bd_stack ) ) ) )
    {
        return NULL;
    }
    
    if( NULL == ( cells = ( bd_cell * )calloc( sizeof( bd_cell ), xalloc ) ) )
    {
        free( stack );
        return NULL;
    }
    
    for( i = 0; i < xalloc; i++ )
    {
        cells[ i ].index = i;
        cells[ i ].prev  = ( i > 0 )              ? &cells[ i - 1 ] : NULL;
        cells[ i ].next  = ( i < ( xalloc - 1 ) ) ? &cells[ i + 1 ] : NULL;
    }
    
    stack->cell   = cells;
    stack->start  = cells;
    stack->end    = cells + ( xalloc - 1 );
    stack->length = xalloc;
    stack->used   = 1;
    stack->xalloc = xalloc;
    
    return stack;
}

/*!
 * @function    bd_delete_stack
 * @abstract    Deletes a stack
 * @param       stack   The stack to delete
 * @result      void
 */
void bd_delete_stack( bd_stack * stack )
{
    free( stack->start );
    free( stack );
}

/*!
 * @function    bd_show_stack
 * @abstract    Prints a stack representation to stdout
 * @param       stack   The BrainFuck stack
 * @result      void
 */
void bd_print_stack( bd_stack * stack )
{
    bd_cell * cell = NULL;
    
    printf
    (
        "  --------------------------------------------------------------------------------\n"
        "  [STACK DEBUG - START]\n"
        "  --------------------------------------------------------------------------------\n"
        "  Number of allocated cells: %i\n"
        "  Number of used cells:      %i\n"
        "  Current cell index:        %i\n"
        "  --------------------------------------------------------------------------------\n",
        stack->length,
        stack->used,
        stack->cell->index
    );
    
    cell = stack->start;
    
    while( cell->next != NULL )
    {
        printf( "  Cell #%i: %i\n", cell->index, cell->value );
        cell = cell->next;
    }
    
    printf( "  Cell #%i: %i\n", cell->index, cell->value );
    
    printf
    (
        "  --------------------------------------------------------------------------------\n"
        "  [STACK DEBUG - END]\n"
        "  --------------------------------------------------------------------------------\n"
    );
}

/*!
 * @function    bd_get_cell
 * @abstract    Gets a specific cell from the stack
 * @param       stack   The BrainFUck stack
 * @param       num     The stack cell index
 * @result      A pointer to the cell, or NULL if the cell cannot be found
 */
bd_cell * bd_get_cell( bd_stack * stack, unsigned int num )
{
    bd_cell * cell = stack->start;
    
    cell = ( num < stack->length ) ? cell + num : NULL;
    
    return cell;
}

/*!
 * @function    bd_prev
 * @abstract    Moves to the previous cell in the stack
 * @param       stack   The BrainFUck stack
 * @result      void
 */
void bd_prev( bd_stack * stack )
{
    if( stack->cell->prev != NULL )
    {
        stack->cell = stack->cell->prev;
    }
}

/*!
 * @function    bd_next
 * @abstract    Moves to the next cell in the stack
 * @param       stack   The BrainFUck stack
 * @result      void
 */
void bd_next( bd_stack * stack )
{
    unsigned int i  = 0;
    bd_cell * cells = NULL;
    
    if( stack->cell->index < ( stack->length - 1 ) )
    {
        stack->cell = stack->cell->next;
    }
    else
    {
        cells = stack->start;
        
        if( NULL == ( cells = ( bd_cell * )realloc( cells, stack->length + stack->xalloc ) ) )
        {
            bd_delete_stack( stack );
            fprintf( stderr, "Error: not enough memory" );
            exit( EXIT_FAILURE );
        }
        
        for( i = 0; i < ( stack->length + stack->xalloc ); i++ )
        {
            cells[ i ].index = i;
            cells[ i ].value = ( i < stack->length )                             ? cells[ i ].value : 0;
            cells[ i ].prev  = ( i > 0 )                                         ? &cells[ i - 1 ]  : NULL;
            cells[ i ].next  = ( i < ( ( stack->length + stack->xalloc ) - 1 ) ) ? &cells[ i + 1 ]  : NULL;
        }
        
        stack->start   = &cells[ 0 ];
        stack->cell    = &cells[ stack->length ];
        stack->length += stack->xalloc;
        stack->end     = &cells[ stack->length - 1 ];
    }
    
    if( stack->cell->index > ( stack->used + 1) )
    {
        stack->used = stack->cell->index + 1;
    }
}

/*!
 * @function    bd_rewind
 * @abstract    Moves to the first cell in the stack
 * @param       stack   The BrainFuck stack
 * @result      void
 */
void bd_rewind( bd_stack * stack )
{
    stack->cell = stack->start;
}

/*!
 * @function    bd_end
 * @abstract    Moves to the last cell in the stack
 * @param       stack   The BrainFUck stack
 * @result      void
 */
void bd_end( bd_stack * stack )
{
    stack->cell = stack->end;
}
