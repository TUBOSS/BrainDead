/*******************************************************************************
 * Copyright (c) 2010, Jean-David Gadina <macmade@eosgarden.com>
 * Distributed under the Boost Software License, Version 1.0.
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 ******************************************************************************/

/* $Id$ */

/*!
 * @header      interpreter.c
 * @copyright   eosgarden 2010 - Jean-David Gadina <macmade@eosgarden.com>
 * @abstract    BrainFuck interpreter functions
 */

#include "braindead.h"

/*!
 * @function    bd_debug
 * @abstract    Debugs a BrainFuck character
 * @param       character       The character to interpret
 * @param       stack           The BrainFuck stack
 * @param       debug           Wheter to print debug informations
 */
void bd_debug( char character, bd_stack * stack, bool debug, ... )
{
    unsigned int counter = 0;
    va_list      args;
    
    if( debug == false )
    {
        return;
    }
    
    va_start( args, debug );
    
    counter = va_arg( args, unsigned int );
    
    va_end( args );
    
    switch( character )
    {
        case '%':
            
            printf( "  [DEBUG] - Reseting stack\n" );
            break;
            
        case '@':
            
            printf( "  [DEBUG] - Entering breakpoint\n" );
            break;
        
        case '$':
            
            printf( "  [DEBUG] - Displaying stack debug informations\n" );
            break;
        
        case '+':
            
            printf( "  [DEBUG] - Incrementing cell #%i value: %i\n", stack->cell->index, stack->cell->value );
            break;
        
        case ',':
            
            printf( "  [DEBUG] - Getting an input character for cell #%i\n", stack->cell->index );
            break;
        
        case '-':
            
            printf( "  [DEBUG] - Decrementing cell #%i value: %i\n", stack->cell->index, stack->cell->value );
            break;
        
        case '.':
            
            printf( "  [DEBUG] - Printing cell #%i value (%i)\n", stack->cell->index, stack->cell->value );
            break;
        
        case '<':
            
            printf( "  [DEBUG] - Moving to previous cell (#%i)\n", stack->cell->index );
            break;
        
        case '>':
            
            printf( "  [DEBUG] - Moving to next cell (#%i)\n", stack->cell->index );
            break;
        
        case '[':
            
            printf( "  [DEBUG] - Begining loop on cell #%i with value %i\n", bd_get_cell( stack, counter )->index, bd_get_cell( stack, counter )->value );
            break;
        
        case ']':
            
            printf( "  [DEBUG] - Ending loop on cell #%i with value %i\n", bd_get_cell( stack, counter )->index, bd_get_cell( stack, counter )->value );
            break;
        
        default:
            
            if( character != 10 && character != 13 )
            {
                printf( "  [DEBUG] - Skipping unrecognized character: %i\n", ( int )character );
                break;
            }
    }
}

/*!
 * @function    bd_interpret_char
 * @abstract    Interprets a BrainFuck character
 * @param       character       The character to interpret
 * @param       stack           The BrainFuck stack
 * @param       debug           Wheter to print debug informations
 * @param       break_point     Wheter to enable '@' symbols (break point)
 * @param       stack_debug     Wheter to enable '$' symbols (stack debug)
 * @param       stack_reset     Wheter to enable '%' symbols (stack reset)
 * @result      void
 */
void bd_interpret_char( char character, bd_stack * stack, bool debug, bool break_point, bool stack_debug, bool stack_reset )
{
    bd_cell * cell = NULL;
    
    switch( character )
    {
        case '%':
            
            if( stack_reset == true )
            {
                bd_debug( character, stack, debug );
                
                cell = stack->start;
                
                while( cell->next != NULL )
                {
                    cell->value = 0;
                    cell        = cell->next;
                }
                
                cell->value = 0;
            }
            break;
        
        case '@':
            
            if( break_point == true )
            {
                bd_debug( character, stack, debug );
                printf( "  [BREAKPOINT] - Press any key to continue..." );
                getchar();
            }
            break;
        
        case '$':
            
            if( stack_debug == true )
            {
                bd_debug( character, stack, debug );
                bd_print_stack( stack );
            }
            break;
        
        case '+':
            
            stack->cell->value++;
            bd_debug( character, stack, debug );
            break;
        
        case ',':
            
            bd_debug( character, stack, debug );
            stack->cell->value = getchar();
            
            if( debug == true )
            {
                printf
                (
                    "  [DEBUG] - Putting input value %i on cell #%i\n",
                    stack->cell->value,
                    stack->cell->index
                );
            }
            break;
        
        case '-':
            
            stack->cell->value--;
            bd_debug( character, stack, debug );
            break;
        
        case '.':
            
            
            bd_debug( character, stack, debug );
            putchar( stack->cell->value );
            
            if( debug == true && stack->cell->value > 31 )
            {
                printf( "\n" );
            }
            break;
        
        case '<':
            
            bd_prev( stack );
            bd_debug( character, stack, debug );
            break;
        
        case '>':
            
            bd_next( stack );
            bd_debug( character, stack, debug );
            break;
        
        default:
            
            bd_debug( character, stack, debug );
            break;
    }
}

/*!
 * @function    bd_interpret
 * @abstract    Interprets BrainFuck code and displays the result to stdout
 * @param       xalloc          The number of stack cells to allocate at a time
 * @param       debug           Wheter to print debug informations
 * @param       break_point     Wheter to enable '@' symbols (break point)
 * @param       stack_debug     Wheter to enable '$' symbols (stack debug)
 * @param       stack_reset     Wheter to enable '%' symbols (stack reset)
 * @result      void
 */
void bd_interpret( unsigned int xalloc, bool debug, bool break_point, bool stack_debug, bool stack_reset )
{
    unsigned char input         = 0;
    bd_stack    * stack         = NULL;
    char        * buffer        = NULL;
    unsigned int  counter       = 0;
    unsigned int  i             = 0;
    bool          in_loop       = false;
    bool          has_loop_code = false;
    
    stack = bd_new_stack( xalloc );
    
    if( debug == true )
    {
        printf( "  [DEBUG] - Initializing stack with %i cells\n", xalloc );
    }
    
    input = getchar();
    
    process:
    
    switch( input )
    {
        case 'q':
        case 'x':
        case 'Q':
        case 'X':
            
            printf( "EXIT - Have a nice day\n" );
            bd_delete_stack( stack );
            return;
        
        case '[':
            
            counter  = stack->cell->index;
            in_loop  = true;
            
            bd_debug( input, stack, debug, counter );
            break;
            
        case ']':
            
            bd_debug( input, stack, debug, counter );
            
            if( has_loop_code == false )
            {
                has_loop_code = true;
                                
                if( NULL == ( buffer = realloc( buffer, sizeof( char ) * ( i + 1 ) ) ) )
                {
                    bd_delete_stack( stack );
                    fprintf( stderr, "Error: not enough memory" );
                    exit( EXIT_FAILURE );
                }

                buffer[ i ] = input;
            }
            
            i = 0;
            
            if( bd_get_cell( stack, counter )->value > 0 )
            {
                if( debug == true )
                {
                    printf( "  [DEBUG] - Entering a new iteration of loop on cell #%i with value %i\n", bd_get_cell( stack, counter )->index, bd_get_cell( stack, counter )->value );
                }
            }
            else
            {
                in_loop       = false;
                has_loop_code = false;
            }
            break;
        
        default:
            
            bd_interpret_char( input, stack, debug, break_point, stack_debug, stack_reset  );
            break;
    }
    
    if( in_loop == true && has_loop_code == true )
    {
        input = buffer[ i ];
        i++;
        
        goto process;
    }
    else if( in_loop == true )
    {
        if( i > 0 )
        {
            if( NULL == ( buffer = realloc( buffer, sizeof( char ) * ( i + 1 ) ) ) )
            {
                bd_delete_stack( stack );
                fprintf( stderr, "Error: not enough memory" );
                exit( EXIT_FAILURE );
            }
            
            buffer[ i ] = input;
        }
        
        i++;
    }
    
    input = getchar();
    
    goto process;
}

/*!
 * @function    bd_interpret_file
 * @abstract    Interprets a file as BrainFuck code and displays the result to stdout
 * @param       file            The file handle
 * @param       xalloc          The number of stack cells to allocate at a time
 * @param       debug           Wheter to print debug informations
 * @param       break_point     Wheter to enable '@' symbols (break point)
 * @param       stack_debug     Wheter to enable '$' symbols (stack debug)
 * @param       stack_reset     Wheter to enable '%' symbols (stack reset)
 * @result      void
 */
void bd_interpret_file( FILE * file, unsigned int xalloc, unsigned int xread, bool debug, bool break_point, bool stack_debug, bool stack_reset )
{
    unsigned int  buffer_length = 0;
    unsigned int  i             = 0;
    unsigned int  counter       = 0;
    unsigned long pos           = 0;
    bd_stack    * stack         = NULL;
    char        * buffer        = NULL;
    
    if( NULL == ( buffer = ( char * )malloc( sizeof( char ) * xalloc ) ) )
    {
        fclose( file );
        fprintf( stderr, "Error: not enough memory" );
        exit( EXIT_FAILURE );
    }
    
    stack = bd_new_stack( xalloc );
    
    if( debug == true )
    {
        printf( "  [DEBUG] - Initializing stack with %i cells\n", xalloc );
    }
    
    while( !feof( file ) )
    {
        buffer_length = fread( buffer, sizeof( char ), sizeof( buffer ), file );
        
        if( debug == true )
        {
            printf
            (
                "  [DEBUG] - Getting %i characters from input file\n"
                "            Characters read: %i\n"
                "            File offset:     %li\n",
                xread,
                buffer_length,
                ftell( file )
            );
        }
        
        for( i = 0; i < buffer_length; i++ )
        {
            switch( buffer[ i ] )
            {
                case '[':
                    
                    pos     = ( ftell( file ) - ( buffer_length - i ) ) + 1;
                    counter = stack->cell->index;
                    
                    bd_debug( buffer[ i ], stack, debug, counter );
                    break;
                
                case ']':
                    
                    bd_debug( buffer[ i ], stack, debug, counter );
                    
                    if( bd_get_cell( stack, counter )->value > 0 )
                    {
                        fseek( file, pos, SEEK_SET );
                        
                        i = buffer_length;
                        
                        if( debug == true )
                        {
                            printf( "  [DEBUG] - Entering a new iteration of loop on cell #%i with value %i\n", bd_get_cell( stack, counter )->index, bd_get_cell( stack, counter )->value );
                        }
                    }
                    
                    break;
                
                default:
                    
                    bd_interpret_char( buffer[ i ], stack, debug, break_point, stack_debug, stack_reset );
                    break;
            }
        }
    }
    
    if( debug == true )
    {
        printf( "  [DEBUG] - End of script\n" );
    }
    
    bd_delete_stack( stack );
}
